// Task.cpp : Определяет функции для статической библиотеки.
//

#include "pch.h"
#include "Task.h"

struct Coordinates
{
	int x, y;
};

struct StackItem		// собственно сам элемент стека
{
	Coordinates point;	// точка
	StackItem* next;	// указатель на следующий элемент в списке
};

StackItem* stack = nullptr; // указатель на вершину стека, изначально стек пуст

bool IsEmpty() // функция проверяет пуст ли стек
{
	return stack == nullptr;
}

void Push(const Coordinates& point) // Добавление точки в стек (аналог функции AddFirst линейного списка)
{
	//StackItem* item = new StackItem{ point, stack }; // этой строчкой можно заменить следующие 2
	StackItem* item = new StackItem; // создаем новый элемент стека
	item->point = point; //инициализируем данные в элементе
	item->next = stack; //корректируем указатель на следующий элемент
	stack = item; // теперь вершина стека указывает на добавленный элемент
}

Coordinates Pop()
{
	Coordinates result; // здесь будет результат
	StackItem* temp; // временная переменная
	if (stack == nullptr) // если стек пуст
	{
		result.x = 0;   // то операция извлечения невозможна
		result.y = 0;   // пока мы не умеем реагировать на такую ситуацию
		return result;  // поэтому пока возвращаем Point {0,0}
	}
	result = stack->point; //записываем возвращаемые данные
	temp = stack;   // запоминаем элемент на вершине стека
	stack = temp->next; // перемещаем вершину стека на следующий за извлекаемым элемент
	delete temp;    // освобождаем память, занятую элементом на вершине
	return result; // возвращаем результат
}

bool ValidationMaze(Coordinates player, char** maze)
{
	Push(player); // помещаем координаты затравочного пикселя в стек
	while (!IsEmpty()) // пока стек не пуст
	{
		Coordinates p = Pop();  // извлекаем пиксел из стека
		if (maze[p.x][p.y] == 'E')
			return true;
		if (maze[p.x][p.y] != '?') // если ему не присвоено значение заливки
			maze[p.x][p.y] = '?'; // заливаем
		
		if (maze[p.x + 1][p.y] != '?' && maze[p.x + 1][p.y] != '#') // проверяем пиксел справа от текущего
			Push(Coordinates{ p.x + 1, p.y }); // если он не закрашен и не является границей, то помещаем его координаты в стек
		if (maze[p.x - 1][p.y] != '?' && maze[p.x - 1][p.y] != '#') // то же для левого
			Push(Coordinates{ p.x - 1, p.y });
		if (maze[p.x][p.y - 1] != '?' && maze[p.x][p.y - 1] != '#') // то же для верхнего
			Push(Coordinates{ p.x, p.y - 1 });
		if (maze[p.x][p.y + 1] != '?' && maze[p.x][p.y + 1] != '#') // то же для нижнего
			Push(Coordinates{ p.x, p.y + 1 });
	}
	return false;
}

void ClearStack()
{
	auto temp = stack; // вспомогательный указатель, который будет указывать на удаляемый элемент
	// в то время, как firstItem мы будем продвигать вперед на следующие элемент
	while (stack != nullptr) // пока не достигли конца списка
	{
		stack = stack->next; // передвигаем "курсор" на следующий элемент
		delete temp;    // удаляем текущий
		temp = stack; // обновляем temp, так чтобы он указывал на следующий
	} // в конце цикла firstItem будет равен nullptr
}

bool CanMoveToExit(char** maze)
{
	int sizeX = 15, sizeY = 15;
	Coordinates player;
	for (int i = 0; i < sizeX; i++)
		for (int j = 0; j < sizeY; j++)
			if (maze[i][j] == 'P')
				player = { i,j };
	bool res = ValidationMaze(player, maze);
	ClearStack;
	return res;
}

/*
Создайте функцию, которая проверяет достижимость выхода из лабиринта.
Функция возвращает в качестве результата новый список, в который включены только те товары, цена которых
лежит в указанном диапазоне цен.

1. Функция должна иметь имя CanMoveToExit
2. Функция в качестве параметров должна принимать следующее:
- первый параметр - символьный двумерный массив размером 15х15 элементов

3. Функция должна возвращать true, если из позиции игрока можно достичь любого из выходов и false в противном случае.

Тип возвращаемого результата - bool.

Этапы решения задачи:

Определите позицию игрока в лабиринте, если таковой нет, то возвращайте false, иначе считайте найденные координаты координатами затравочного пискеля.
Используя алгоритм заполнения гранично-определенной области с затравкой на основе стека определите, возможно ли достичь выхода. Достижением выхода считается факт, что вы при анализе очередного пикселя наткyулись на пиксель E. Если такой пиксель не будет найден - лабиринт непроходим.
Граничным символом в вашей задаче будет символ стены #. В процессе заливки лабиринта вы меняете любые отличные от # символы на символ - заполнитель. Пусть, например им будет символ "?".

	!!!!! ВАЖНО !!!!!
	В данном файле разрешается разместить кроме кода требуемой функции - код любых других вспомогательных
	функций. Никакой функции main() в этом файле быть не должно.
	Если вы хотите испытать и отладить вашу функцию - пишите код в файле Example.cpp проекта Example данного решения
	Для этого задайте в качестве запускаемого проекта проект Example.

	ДЛЯ АВТОМАТИЧЕСКОГО ТЕСТИРОВАНИЯ  проверки правильности работы вашего задания - сделайте запукаемым проект
	Tests и запустите его. Если функция написана правильно - все тесты должны успешно выполниться
	(зеленый цвет в консоли). Если ваша функция работает некорректно - в консоли будут сообщения красным цветом
*/
